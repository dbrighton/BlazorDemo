@inherits FluxorComponent
@inject IState<ChessState> State
@inject IDispatcher Dispatcher




<div class="chess-board">
    <table > 
        @for (var row = 8; row >= 1; row--) // Start from 8 and go down to 1 for rows
        { 
            <tr> 
                @for (var col = 1; col <= 8; col++) 
                { 
                    var cellId = ChessExtensions.GetBoardPosition($"{(char) (col + 96)}{row}"); // e.g., "a8", "b8", ... "h1" *@
                    var piece = GetChessPiece(cellId); 
                    <td align="center"> 
                        <div ondragover="@(() => AllowDrop(cellId))" draggable="true" 
                             ondragstart="@(() => OnDragStart(piece))" 
                             ondragend="@(() => OnDragEnd(piece))"> 
    
                            <ChessCellCtrl CellId="@cellId" ChessPiece="@piece"/> 
                        </div> 
    
                    </td> 
                } 
            </tr> 
        } 
        
    </table>
    <img src="_content/FluxorChess/Images/Marble-Floor-Texture.jpg" />
    <div class="m-2">
        <br />
        <button class="btn btn-primary" @onclick="NewGame">New Game</button>
        <button class="btn btn-outline-danger" @onclick="Resign">Resign</button>
    </div>
</div>




@code
{
    private ChessPlayer? _player;
    private ChessPiece _draggedPiece;
    private BoardPosition? _droppedCellId;

    [Parameter]
    public Models.ChessGame Game { get; set; }


    protected override void OnInitialized()
    {
        base.OnInitialized();
        SubscribeToAction<ChessPiecesUpdateReducerAction>(result =>
        {
            Game = State.Value.CurrentGame;

            Dispatcher.Dispatch(new MoveChessPieceEffectsAction(Game));
        });
    }

    private ChessPiece? GetChessPiece(BoardPosition cellId)
    {
        var target = (from i in State.Value.CurrentGame.ChessPieces
            where i.CellId == cellId
            select i).FirstOrDefault();

        return target;
    }

    private void AllowDrop(BoardPosition cellId)
    {
        _droppedCellId = cellId;
    }

    private void OnDragStart(ChessPiece piece)
    {
        _draggedPiece = piece;
    }


    private void OnDragEnd(ChessPiece chessPiece)
    {
        var startCellId = chessPiece.CellId;
        if (IsMoveAllowed(chessPiece))
        {
            var enemy = (from i in Game.ChessPieces
                where i.CellId == _droppedCellId
                select i).FirstOrDefault();

            if (enemy != null)
            {
                enemy.IsCaptured = true;

                Game.ChessPieces.Remove(enemy);
                Game.CapturedChessPieces.Add(enemy);
            }
        }

        chessPiece.CellId = (BoardPosition) _droppedCellId;


        _droppedCellId = null;


        Dispatcher.Dispatch(new ChessPiecesUpdateReducerAction(startCellId, chessPiece));
        if (State.Value.CurrentGame != null)
        {
            Dispatcher.Dispatch(new MoveChessPieceEffectsAction(State.Value.CurrentGame));
        }
    }

    private bool IsMoveAllowed(ChessPiece chessPiece)
    {
        return true;
    }


    private void NewGame()
    {
        var game = State?.Value?.CurrentGame;
        if (game != null)
        {
            Dispatcher.Dispatch(new MoveChessPieceEffectsAction(game.ResetGame()));
        }
    }

    private void Resign()
    {
        var game = State?.Value?.CurrentGame;
        if (game != null)
        {
            Dispatcher.Dispatch(new ResignGameEffectsAction(game));
        }
    }
}