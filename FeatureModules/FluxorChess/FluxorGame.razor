@using FluxorChess.Utils
@inherits FluxorComponent
@inject IState<ChessState> State
@inject IDispatcher Dispatcher

<table class="chess-board">
    @for (int row = 8; row >= 1; row--) // Start from 8 and go down to 1 for rows
    {
        <tr>
            @for (int col = 1; col <= 8; col++)
            {
                string cellId = $"{(char)(col + 96)}{row}"; // e.g., "a8", "b8", ... "h1"
                ChessPiece? piece = GetChessPiece(cellId);
                <td align="center">
                    <div ondragover="@(()=>AllowDrop(cellId))" draggable="true"
                         ondragstart="@(() => OnDragStart(piece))"
                         ondragend="@(() => OnDragEnd(piece))">

                        <ChessCellCtrl CellId="@cellId" ChessPiece="@piece" />
                    </div>

                </td>
            }
        </tr>
    }
</table>



@code
{
    private ChessGame _game;
    private ChessPiece _draggedPiece;
    private string _droppedCellId;

    [Parameter]
    public ChessGame Game
    {
        get => _game;
        set => _game = value;
    }




    protected override void OnInitialized()
    {

        base.OnInitialized();
        SubscribeToAction<ChessPiecesUpdateReducerAction>(result =>
        {
            _game = State.Value.CurrentGame;

            Dispatcher.Dispatch(new MoveChessPieceEffectsAction(_game));
        });

        
      
    }

    private ChessPiece? GetChessPiece(string cellId)
    {

        var target = (from i in State.Value.CurrentGame.ChessPieces
                      where i.CellId == cellId
                      select i).FirstOrDefault();

        return target;
    }

    private void AllowDrop(string cellId)
    {
        _droppedCellId = cellId;
    }

    private void OnDragStart(ChessPiece piece)
    {
        _draggedPiece = piece;

    }


    private void OnDragEnd(ChessPiece chessPiece)
    {
        var startCellId = chessPiece.CellId;
        if (IsMoveAllowed(chessPiece))
        {
            var enemy = (from i in _game.ChessPieces
                where i.CellId == _droppedCellId
                select i).FirstOrDefault();

            if (enemy != null)
            {
                enemy.CellId = "0";
                enemy.IsDead = true;

                _game.ChessPieces.Remove(enemy);
                _game.CapturedChessPieces.Add(enemy);
            }
        }

        chessPiece.CellId = _droppedCellId;
       
        chessPiece.X = (int)Char.GetNumericValue(_droppedCellId.ToCharArray()[1]);
        chessPiece.Y = _droppedCellId.ToCharArray()[0] ;

        _droppedCellId = null;

       

        Dispatcher.Dispatch(new ChessPiecesUpdateReducerAction(startCellId,chessPiece));
        if (State.Value.CurrentGame != null)
        {
            Dispatcher.Dispatch(new MoveChessPieceEffectsAction(State.Value.CurrentGame));
        }
    }

    private bool IsMoveAllowed(ChessPiece chessPiece)
    {
        return true;
    }


  


}